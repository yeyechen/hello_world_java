package 左程云体系学习班;

public class Lecture34 {

  /*
   * 资源限制类题目的解题套路
   * *布隆过滤器用于集合的建立与查询，并可以节省大量空间 (已讲)
   * *一致性哈希解决数据服务器的负载管理问题 (已讲)
   * *利用并查集结构做岛问题的并行计算 (已讲)
   * 1.哈希函数可以把数据按照种类均匀分流
   * 2.位图解决某一范围上数字的出现情况，并可以节省大量空间
   * 3.利用分段统计思想、并进一步节省大量空间
   * 4.利用堆、外排序来做多个处理单元的结果合并
   *
   * 1.哈希函数可以把数据按照种类均匀分流:
   * 题目：32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，
   * 可以使用最多1GB的内存，怎么找到出现次数最多的数？
   *
   * 40亿个数，我们考虑最坏的情况，这40亿个数各不同，会占用哈希表40亿条记录(因为如果一个数出现多次，只占用一条哈希表
   * 记录，比如(key=23, value=2000) 23这个数出现了2000次)。一条哈希记录，假设占8 Byte，因为一个int占4 Byte,
   * (int, int)占8 Byte。1G = 10^9 Byte / 8 Byte = 125,000,000，这是哈希表中最多可以承担的记录数。那么现在
   * 假设哈希表中其他空间消耗，比如指针，1G哈希表可承担的记录数再缩小，假设10,000,000 这是非常保守的估计。那么最坏
   * 情况40亿除以10,000,000 = 400。
   * 利用哈希函数把数据种类分流：
   * 有一个哈希函数 f，将这40亿个数都应用 f，mod 400，那么这40亿个数会被均匀地分配到400个小文件中去(把原文件的空间
   * 分割成400个小文件，不占额外空间)，因为哈希函数的离散性。并且，因为相同输入一定会有相同输出，我们就可以统计单个小
   * 文件中出现次数最多的数字。利用哈希表统计一次，即便这小文件中没有重复的数，10,000,000条记录也不会超过1G。统计出
   * 现最多的数字，释放哈希表，再统计下一个小文件出现最多的数字，释放。以此类推。最后再从这400个数字中遍历出次数最多
   * 的数字，这过程仅需要2个变量即可完成。
   *
   * 题目2： 有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
   * 补充：某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法
   *
   * 首先，如果允许失误率的话可以用布隆过滤器。如果不允许失误率，用哈希来分流。在每一个分开的小组中查找重复的URL。如果
   * 一次不够就再分第二次。
   *
   * 2.位图解决某一范围上数字的出现情况，并可以节省大量空间
   * 题目：32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，
   * 所以在整个范围中必然存在没出现过的数，可以使用最多1GB的内存，怎么找到所有未出现过的数？
   *
   * 用位图，用int[]来表示bit数组。一个int可以表示32位，且占4 Byte。总共需要2^32个bit，2^32 / 8 = 5.4 * 10^8,
   * 不到1G。在这40亿个数当中，我们要在bit数组中把所有数设置为1，剩余的数则为0，是未出现的。比如一个数 k，在arr数组
   * 中的位置为：index=k/32，第k%32位。提取状态时，(arr[k/32] & 1 << k%32) == 0 ? 0 : 1
   * 如果题目变为怎么找到所有出现了两次的数，可以用2个bit来代表一个数出现的次数：00表示没出现，01表示出现一次，10表示
   * 出现两次，11表示出现三次及以上。结果就是2^32 / 8 * 2 = 1073 * 10^6, 1G多一点点。
   *
   *
   * 3.利用分段统计思想、并进一步节省大量空间
   * 题目：进阶：内存限制为 3KB，但是只用找到一个没出现过的数即可
   *
   * 3KB = 3000Byte, 3000 Byte /4 Byte = 750 。我们可以申请一个长度小于等于750的数组。为了均分，让这个长度位
   * 2的某一次方，比如512。2^32/512 = 2^23，那么这40亿个数，来统计范围个数，
   * 范围分别为arr[0]为0~2^23，arr[1]为2^23~2^24，arr[2]为2^23~2^24...arr[512]为2^31~2^32。
   * 那么在这些index中，有些数出现多次，数量会超过2^23，那么必然会有某些index，不满2^23个数，找到这个index，我们就
   * 知道它所代表的数的范围，说明在这个范围上，有数没出现。释放这个数组，再在这个范围上利用这个数组，分512份，统计范围
   * 出现的数量。每次都/512，很快就能锁定某一个没出现的数。
   * 如果为有限几个变量，一样的，L，R，mid，两侧总有一侧不够2^31个个数，二分。有3KB的情况下就相当于512分。
   *
   * 题目2: 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多3KB的内存，怎么找到这40亿个整数的中位数？
   * 同样的，申请一个长度为512的int[]，40亿个数的中位数时第20亿个。
   * 同样分别统计范围个数：arr[0]为0~2^23，arr[1]为2^23~2^24，arr[2]为2^23~2^24...arr[512]为2^31~2^32。
   * 当该arr的i位置的累加和<20亿，并且i+1位置的累加和>=20亿时，该中位数在i+1位置上。算出offset，我们要该i+1位置
   * 代表的范围第offset小的数，递归下去。
   *
   * 4.利用堆、外排序来做多个处理单元的结果合并
   * 题目：32位无符号整数的范围是0~4294967295，有一个10G大小的文件，每一行都装着这种类型的数字，
   * 整个文件是无序的，给你5G的内存空间，请你输出一个10G大小的文件，就是原文件所有数字排序的结果
   *
   * 不管时几个G的空间，用大根堆来做。遍历一次这个文件，用大根堆排好序，并且记录最小的前几个数出现了几次，依次写入输出
   * 文件中。当达到空间限制时，释放大根堆，记录上一次排序中最大的数字，第二次遍历只考虑比该数大的数，再利用大根堆排序，
   * 依次写入文件中。遍历几次就可以正确输出排序好的文件。
   *
   *  */


}
